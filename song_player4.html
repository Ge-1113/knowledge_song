<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>智能播放器</title>
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; padding: 24px; background: #f4f7f6; color: #333; }
    .box { max-width: 600px; margin: 40px auto; background: white; padding: 30px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); text-align: center; }
    #subtitle { margin: 20px 0; font-size: 24px; font-weight: bold; color: #2c3e50; min-height: 72px; line-height: 1.4; display: flex; align-items: center; justify-content: center; }
    audio { width: 100%; border-radius: 10px; margin-top: 10px; }
    .status { font-size: 12px; color: #999; margin-top: 15px; }
  </style>
</head>
<body>
  <div class="box">
    <div id="subtitle">正在加载音乐数据...</div>
    <audio id="player" controls></audio>
    <div class="status" id="status">连接中...</div>
  </div>

  <script>
    const subtitleEl = document.getElementById("subtitle");
    const audio = document.getElementById("player");
    const statusEl = document.getElementById("status");

    // 1. 解析参数
    const urlParams = new URLSearchParams(window.location.search);
    const songParam = urlParams.get('song'); 
    const targetFile = songParam ? `./${songParam}` : './data/song_info.json';
    const DATA_URL = `${targetFile}?t=${new Date().getTime()}`;

    // 2. 解析 SRT 核心函数
    function toSeconds(t) {
      const [hms, ms] = t.split(",");
      const [h, m, s] = hms.split(":").map(Number);
      return h * 3600 + m * 60 + s + (Number(ms) || 0) / 1000;
    }

    function parseSrt(srt) {
      if (!srt) return [];
      const blocks = srt.replace(/\r/g, "").trim().split(/\n\s*\n/);
      return blocks.map(block => {
        const lines = block.split("\n");
        if (lines.length < 3) return null;
        const timeLine = lines[1];
        const m = timeLine.match(/(\d+:\d+:\d+,\d+)\s*-->\s*(\d+:\d+:\d+,\d+)/);
        if (!m) return null;
        return { 
          start: toSeconds(m[1]), 
          end: toSeconds(m[2]), 
          text: lines.slice(2).join("\n").trim() 
        };
      }).filter(Boolean);
    }

    // 3. 同步渲染函数
    function setupSync(player, cues) {
      let lastIndex = -1;
      player.addEventListener("timeupdate", () => {
        const t = player.currentTime;
        let found = -1;
        // 查找当前时间对应的字幕索引
        for (let i = 0; i < cues.length; i++) {
          if (t >= cues[i].start && t <= cues[i].end) { found = i; break; }
        }
        if (found !== lastIndex) {
          lastIndex = found;
          subtitleEl.textContent = (found === -1) ? "" : cues[found].text;
        }
      });
      player.addEventListener("seeked", () => { lastIndex = -1; });
    }

    // 4. 初始化加载
    async function init() {
      try {
        statusEl.textContent = "正在获取云端 JSON...";
        const response = await fetch(DATA_URL);
        if (!response.ok) throw new Error("文件尚未同步，请稍后刷新");
        
        const data = await response.json();
        audio.src = data.audio;
        const cues = parseSrt(data.srt);
        
        setupSync(audio, cues);
        subtitleEl.textContent = "准备就绪";
        statusEl.textContent = "已加载文件: " + targetFile;
      } catch (err) {
        subtitleEl.textContent = "加载失败";
        statusEl.textContent = err.message;
      }
    }

    init();
  </script>
</body>
</html>
