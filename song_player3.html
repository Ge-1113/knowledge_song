<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>智能播放器</title>
  <style>
    body { font-family: system-ui, sans-serif; padding: 24px; background: #f4f7f6; color: #333; }
    .box { max-width: 600px; margin: 40px auto; background: white; padding: 30px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); text-align: center; }
    #subtitle { margin: 20px 0; font-size: 24px; font-weight: bold; color: #2c3e50; min-height: 60px; line-height: 1.5; }
    audio { width: 100%; border-radius: 10px; }
    .status { font-size: 12px; color: #999; margin-top: 15px; }
  </style>
</head>
<body>
  <div class="box">
    <div id="subtitle">正在加载音乐数据...</div>
    <audio id="player" controls></audio>
    <div class="status" id="status">连接中...</div>
  </div>

  <script>
    const subtitleEl = document.getElementById("subtitle");
    const audio = document.getElementById("player");
    const statusEl = document.getElementById("status");

    // 【关键】读取刚才 Python 插件写入的 JSON 文件
    // 加上 ?t= 时间戳是为了强制刷新缓存，否则 GitHub Pages 会有几分钟延迟
    const DATA_URL = "./data/song_info.json?t=" + new Date().getTime();

    async function init() {
      try {
        const response = await fetch(DATA_URL);
        if (!response.ok) throw new Error("无法获取歌曲配置");
        
        const data = await response.json();
        
        // 设置音频地址
        audio.src = data.audio;
        
        // 解析 SRT
        const cues = parseSrt(data.srt);
        
        // 绑定播放同步逻辑
        setupSync(audio, cues);
        
        subtitleEl.textContent = "准备就绪，点击播放";
        statusEl.textContent = "数据更新于: " + new Date().toLocaleString();
      } catch (err) {
        subtitleEl.textContent = "加载失败";
        statusEl.textContent = err.message;
      }
    }

    // --- SRT 解析逻辑 ---
    function toSeconds(t) {
      const [hms, ms] = t.split(",");
      const [h, m, s] = hms.split(":").map(Number);
      return h * 3600 + m * 60 + s + (Number(ms) || 0) / 1000;
    }

    function parseSrt(srt) {
      const blocks = srt.replace(/\r/g, "").trim().split(/\n\s*\n/);
      return blocks.map(block => {
        const lines = block.split("\n");
        const m = lines[1]?.match(/(\d+:\d+:\d+,\d+)\s*-->\s*(\d+:\d+:\d+,\d+)/);
        if (!m) return null;
        return { start: toSeconds(m[1]), end: toSeconds(m[2]), text: lines.slice(2).join("\n").trim() };
      }).filter(Boolean);
    }

    // --- 同步逻辑 ---
    function setupSync(player, cues) {
      let lastIndex = -1;
      player.addEventListener("timeupdate", () => {
        const t = player.currentTime;
        let found = cues.findIndex(c => t >= c.start && t <= c.end);
        if (found !== lastIndex) {
          lastIndex = found;
          subtitleEl.textContent = (found === -1) ? "" : cues[found].text;
        }
      });
    }

    init();
  </script>
</body>
</html>
